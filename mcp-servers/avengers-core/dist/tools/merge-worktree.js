/**
 * Merge Worktree Tool
 *
 * 완료된 워크트리를 메인 브랜치에 머지하고 정리합니다.
 */
import { globalState } from "../index.js";
import { execSync } from "child_process";
export const mergeWorktreeTool = {
    name: "avengers_merge_worktree",
    description: "Merge a completed worktree back to main and clean up. Use after an agent completes their isolated work.",
    inputSchema: {
        type: "object",
        properties: {
            taskId: {
                type: "string",
                description: "Task ID associated with the worktree"
            },
            createPR: {
                type: "boolean",
                description: "Create a pull request instead of direct merge",
                default: false
            },
            commitMessage: {
                type: "string",
                description: "Custom commit message for the merge"
            }
        },
        required: ["taskId"]
    }
};
export async function handleMergeWorktree(args) {
    const { taskId, createPR, commitMessage } = args;
    // 태스크 조회
    const task = globalState.tasks.get(taskId);
    if (!task) {
        return {
            content: [{ type: "text", text: `Unknown task: ${taskId}` }],
            isError: true,
        };
    }
    if (!task.worktree) {
        return {
            content: [{ type: "text", text: `Task ${taskId} has no associated worktree` }],
            isError: true,
        };
    }
    const worktreePath = task.worktree;
    const branchName = `feature/${taskId}-${task.assignee}`;
    try {
        if (createPR) {
            // PR 생성 (gh CLI 사용)
            const prTitle = commitMessage || `[${taskId}] ${task.title}`;
            const prBody = `## Task: ${task.title}\n\nAssignee: ${task.assignee}\n\n---\nGenerated by Avengers MCP Server`;
            const prUrl = execSync(`cd ${worktreePath} && git push -u origin ${branchName} && gh pr create --title "${prTitle}" --body "${prBody}"`, { encoding: "utf-8" }).trim();
            // 워크트리 정리
            execSync(`git worktree remove ${worktreePath}`, { encoding: "utf-8" });
            return {
                content: [{
                        type: "text",
                        text: JSON.stringify({
                            message: "Pull request created successfully",
                            taskId,
                            branch: branchName,
                            prUrl,
                            worktreeRemoved: true
                        }, null, 2)
                    }],
            };
        }
        else {
            // 직접 머지
            const mergeMessage = commitMessage || `Merge ${branchName}: ${task.title}`;
            execSync(`cd ${worktreePath} && git add -A && git commit -m "${mergeMessage}" || true`, { encoding: "utf-8" });
            execSync(`git checkout main && git merge ${branchName} -m "${mergeMessage}"`, { encoding: "utf-8" });
            // 워크트리 및 브랜치 정리
            execSync(`git worktree remove ${worktreePath}`, { encoding: "utf-8" });
            execSync(`git branch -d ${branchName}`, { encoding: "utf-8" });
            // 상태 업데이트
            task.status = "completed";
            task.worktree = undefined;
            if (task.assignee) {
                const agentState = globalState.agents.get(task.assignee);
                if (agentState) {
                    globalState.agents.set(task.assignee, {
                        ...agentState,
                        status: "idle",
                        currentTask: undefined,
                        worktree: undefined,
                    });
                }
            }
            return {
                content: [{
                        type: "text",
                        text: JSON.stringify({
                            message: "Worktree merged successfully",
                            taskId,
                            branch: branchName,
                            mergedTo: "main",
                            worktreeRemoved: true,
                            branchDeleted: true
                        }, null, 2)
                    }],
            };
        }
    }
    catch (error) {
        return {
            content: [{
                    type: "text",
                    text: `Error during merge: ${error instanceof Error ? error.message : String(error)}`
                }],
            isError: true,
        };
    }
}
